\documentclass{article}
\usepackage[8pt]{extsizes}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}

\author{B.~\textsc{Le Gloannec} -- P.~\textsc{Robert} -- P.~\textsc{Roux} -- T.~\textsc{Trunck}}
\title{Algorithmes pour l'ACM--ICPC}

\usepackage{geometry}
%\usepackage{stmaryrd}
\geometry{lmargin=1.5cm, rmargin=1.5cm, vmargin=1.5cm}
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage{multicol}

\usepackage{color}

\usepackage{listings}
\lstset{language=C++}

\begin{document}

\everymath{\displaystyle }

\lstdefinestyle{code}{language=C++,basicstyle=\ttfamily,keywordstyle=\bf,numbers=left}
\lstdefinestyle{emacs}{language=lisp,basicstyle=\ttfamily,keywordstyle=\bf}

\def\code#1{\lstinputlisting[style=code]{Code/#1}} % Raccourcis

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\footrulewidth}{0.5pt}
\renewcommand{\headrulewidth}{0.5pt}
\lhead{\footnotesize \sffamily Algorithmes pour l'ACM--ICPC}
\rhead{\footnotesize \sffamily BLG -- PR -- TT}
%\lfoot{\ttfamily\footnotesize \today}
\cfoot{\sffamily\footnotesize \thepage/\pageref{lastpage}}
%\rfoot{\ttfamily\footnotesize \jobname.tex}

%%%%%%% D E B U T %%%%%%%%%%%%%%%

\maketitle

\tableofcontents

\section{Préliminaires}

\begin{center}
\fbox{\texttt{using namespace std;}}
\end{center}

\subsection{Abbréviations}
\begin{itemize}
\item \texttt{RINN} : Remove If Not Necessary
\item \texttt{SINN} : Simplify If Not Necessary
\item \texttt{SIP} : Simplify If Possible
\end{itemize}

%\subsection{.emacs}

%\lstinputlisting[style=emacs]{Code/.emacs}

\section{Graphes}

\subsection{Structures et parcours}
\subsubsection{Structures}

\parbox{0.5\textwidth}{\code{Graphes/struct-mat.cpp}}
\parbox{0.5\textwidth}{\code{Graphes/struct-list.cpp}}

\subsubsection{Profondeur (DFS)}

\parbox{0.5\textwidth}{\code{Graphes/dfs-mat.cpp}}
\parbox{0.5\textwidth}{\code{Graphes/dfs-list.cpp}}


\subsubsection{Largeur (BFS)}

\parbox{0.5\textwidth}{\code{Graphes/bfs-mat.cpp}}
\parbox{0.5\textwidth}{\code{Graphes/bfs-list.cpp}}


\subsection{Plus courts chemins -- Source unique}

\subsubsection{Bellman--Ford}

\'Egalement utile pour la détection de cycles de poids négatif (si on ne veut que cela, on peut alors prendre \texttt{INTMAX=0} et n'importe quel sommet pour \texttt{start}).

\code{Graphes/bellman-ford.cpp}


\subsubsection{Dijkstra}

\`A n'utiliser qu'avec des poids positifs.

\code{Graphes/dijkstra.cpp}


\subsection{Plus courts chemins -- Toutes paires de sommets (matrices)}
\subsubsection{Premier algorithme (matrices)}

Algo de prog. dyn. en $n^4$ sur la taille du chemin.

\code{Graphes/premier-algo.cpp}

\subsubsection{Floyd--Warshall (matrices)}

Algo de prog. dyn. en $n^3$ sur le nombre de sommets.

\code{Graphes/floyd-warshall.cpp}


\subsection{MaxFlox--MinCut}

\subsubsection{Ford--Fulkerson}

Choisir le BFS en fonction du mode de représentation des graphes.

\code{Graphes/ford-fulkerson.cpp}

\subsubsection{Calcul des arêtes de la coupe}

Si $S$ est l'ensemble des sommets accessibles depuis la source $s$ dans le graphe résiduel final ($(S,E\backslash S)$ forme une coupe du graphe), les arêtes de la coupe sont les arêtes (du graphe initial) adjacentes aux sommets de $S$ qui mênent vers des sommets qui ne sont pas dans $S$. $S$ étant déconnecté du reste du graphe (dans le graphe résiduel), ses arêtes sont nécessairement toutes saturées (et n'existent plus dans le graphe résiduel).

\parbox{0.5\textwidth}{\code{Graphes/cut-mat.cpp}}
\parbox{0.5\textwidth}{\code{Graphes/cut-list.cpp}}

\subsubsection{Application aux couplages maximaux de graphes bipartis}

\noindent Pour un graphe biparti $(U,V)$ :
\begin{enumerate}
\item On affecte une capacité 1 à toutes les arêtes.
\item On ajoute 2 sommets $s$ et $p$.
\item On relie $s$ à tous les sommets de $U$ par des arêtes de capacité infinie.
\item On relie tous les sommets de $V$ à $p$ par des arêtes de capacité infinie.
\item On calcule Ford--Fulkerson de $s$ à $p$. La capacité du flot maximal est exactement le nombre d'arêtes d'un couplage maximal.
\end{enumerate}

\subsection{Union-find (Tarjan) et arbre couvrant de poids minimal (MST)}

\code{Graphes/tarjan-kruskal.cpp}

\subsection{Cycles/chemins eulériens}

Un graphe connexe possède une chaine eulérienne si et
seulement si ses sommets sont tous de degré pair sauf au plus
deux.

Un graphe connexe possède un cycle eulérien si et seulement si tous ses sommets sont de degré pair.

\section{Affectation}

\code{Graphes/mariage.cpp}

\section{Th\'eorie des nombres}
\subsection{Test de primalité}

\code{Nombres/is_prime.cpp}

\subsection{Cribles}

\code{Nombres/eratosthene.cpp}

\subsection{Décomposition en nombres premiers}

\code{Nombres/decomp.cpp}

\subsection{Euclide}

\code{Nombres/euclide.cpp}

\subsection{Division euclidienne et modulo sur polynômes}

\code{Nombres/polynomes.cpp}

\section{Grands entiers}

Grands entiers avec addition.

\code{Nombres/bigint.cc}

%\section{Programmation linéaire -- Simplex}

\section{G\'eom\'etrie}

\subsection{Structures et opérations de base}

\subsubsection{Structures}

\code{Geometrie/struct-point.cc}

\subsubsection{Déterminant}

\code{Geometrie/det.cc}

\subsubsection{Intersection de deux segments}

\code{Geometrie/inter_segment.cc}

\subsubsection{Calcul de distance}

\code{Geometrie/dist.cc}

Version signée :

\code{Geometrie/dist-sig.cc}

\subsection{Enveloppes convexes}

\code{Geometrie/enveloppe_convexe.cc}

\subsection{Calculs d'aires}

\code{Geometrie/aire_poly.cc}

\subsection{Distance minimale entre 2 points}

\code{Geometrie/plus_proche_paire.cc}

\subsection{Balayages}
\subsubsection{Aire de rectangles superposés}

\code{Geometrie/balayage_aire_rectangles.cc}

\subsubsection{Intersections de segments 2D par balayage}

\code{Geometrie/balayage_inter_segment.cc}

\subsection{Intersection de polygones convexes}

\code{Geometrie/inter_polys_convexes.cc}

\section{Automates finis}
\subsection{Arbres lexicographiques}

\code{Automates/lextree.cpp}

%\subsection{Déterminisation -- Minimisation}

%\code{Automates/automates.cpp}


%%%%%%%  F  I  N  %%%%%%%%%%%%%%%
\label{lastpage}
\end{document}
