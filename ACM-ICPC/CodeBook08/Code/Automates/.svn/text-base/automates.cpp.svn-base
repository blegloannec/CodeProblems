#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
using namespace std;

#define EPSILON 255 // RINN

struct trans { //transition
  char alpha;
  int state; // lettre, nouvel etat
  trans(char b, int s) : alpha(b), state(s) {};
};

typedef vector<trans> liste;
typedef vector<liste> table;
typedef set<int> partie; // partie des etats

struct automate {
  table delta;
  partie init,final;
  void clear() {
    delta.clear();
    init.clear();
    final.clear();
  }
};

bool accepte(automate &a, int state, char *buff, int i0, int imax) { 
  /* teste l'acceptation de buff[i0..imax] depuis l'etat state
     cas general : accepte(init,buff,0,buff_size-1) */
  if (imax <= i0) return (a.final.find(state)!=a.final.end());
  liste::iterator it = a.delta[state].begin();
  while (it!=a.delta[state].end()) {
    if (it->alpha == buff[i0]) 
      return accepte(a,it->state,buff,i0+1,imax)
    else if (it->alpha == (char)EPSILON)
      return accepte(a,it->state,buff,i0,imax); // RINN et Warn. boucles infinies possibles !
    ++it;
  }
  return false;
}

bool accepte_from_init(automate &a, char *buff, int i0, int imax) {
  partie::iterator it;
  for (it=a.init.begin(); it!=a.init.end(); ++it)
    if (accepte(a,*it,buff,i0,imax)) return true;
  return false;
}

// variables globales pour image et determinise
#define ALPHSIZE 4 // taille de l'alphabet
char alpha[ALPHSIZE] = {'A','B','C','D'}; // alphabet
map<char,int> hashalpha; // table alphabet -> numero

void initalpha() { // a appeler 1 fois avant la premiere determinisation
  // construction de la table de hashage des caracteres
  for (int i=0; i<ALPHSIZE; ++i) hashalpha.insert(pair<char,int>(alpha[i],i));
}

void image(automate &a, partie &X, partie Y[ALPHSIZE]) { // y:=delta(X)
  for (int i=0; i<ALPHSIZE; ++i) Y[i].clear(); // Init RINN
  partie::iterator it;
  liste::iterator tit;
  for (it=X.begin(); it!=X.end(); ++it) 
    for (tit=a.delta[*it].begin(); tit!=a.delta[*it].end(); ++tit) 
      Y[hashalpha[tit->alpha]].insert(tit->state);
}

void determinise(automate &a, automate &adet) {
  adet.clear(); // Init RINN
  vector<partie> ssens; // tableau des parties
  map<partie,int> hashparts; // table partie -> numero
  int ind = 0;
  partie Y[ALPHSIZE];
  partie::iterator it;
  map<partie,int>::iterator mit;
  ssens[0] = a.init;
  hashparts.insert(pair<partie,int>(ssens[0],0));
  int hsize = 1;
  while (ind!=(int)ssens.size()) {
    image(a,ssens[ind],Y);
    for (int c=0; c<ALPHSIZE; ++c) 
      if (!Y[c].empty()) {
	mit = hashparts.find(Y[c]);
	if (mit==hashparts.end()) {
	  hashparts[Y[c]] = hsize;
	  adet.delta[ind].push_back(trans(alpha[c],hsize));
	  ++hsize;
	}
	else 
	  adet.delta[ind].push_back(trans(alpha[c],mit->second));
      }
    ++ind;
  }
  // Construction des etats initiaux et finals
  adet.init.insert(hashparts[a.init]);
  for (int i=0; i<(int)ssens.size(); ++i) 
    for (it=a.final.begin(); it!=a.final.end(); ++it)
      if (ssens[i].find(*it)!=ssens[i].end()) {
	adet.final.insert(i);
	break;
      }
}

void miroir(automate &a, automate &arev) {
  arev.clear();
  arev.final = a.init;
  arev.init = a.final;
  liste::iterator lit;
  for (int i=0; i<(int)a.delta.size(); ++i)
    for (lit=a.delta[i].begin(); lit!=a.delta[i].end(); ++lit)
      arev.delta[lit->state].push_back(trans(lit->alpha,i));
}

void minimise(automate &a, automate &amin) {
  automate arev;
  miroir(a,arev);
  determinise(arev,amin);
  miroir(amin,arev);
  determinise(arev,amin);  
}
  
bool ordre(const trans &t1, const trans &t2) {
  return t1.alpha<t2.alpha;
}

#define MAX 50
char nerode[MAX][MAX];

bool equivalence(automate &a, int sa, automate &b, int sb) {
  /* Equivalence de Nerode de sa et sb pour a et b tries 
     et listes de meme longueur.
     NE TRAITE PAS LES EPSILON*/
  if (nerode[sa][sb]==0) return false;
  if (nerode[sa][sb]==1) return true;
  for (int i=0; i<(int)a.delta[sa].size(); ++i) 
    if (!(equivalence(a,a.delta[sa][i].state,b,b.delta[sb][i].state))) {
      nerode[sa][sb] = 0;
      return false;
    }
  nerode[sa][sb] = true;
  return true;
}

bool isomorphes(automate &a, automate &b) {
  // teste l'egalite des automates
  int S = (int)a.delta.size();
  if (S!=(int)b.delta.size()) return false;
  for (int i=0; i<S; ++i) {
    if (a.delta[i].size()!=b.delta.size()) return false;
    sort(a.delta[i].begin(),a.delta[i].end(),ordre);
    sort(a.delta[i].begin(),a.delta[i].end(),ordre);
  }
  bool ifinal,jfinal;
  for (int i=0; i<S; ++i) {
    ifinal = (a.final.find(i)!=a.final.end());
    for (int j=0; i<S; ++j) {
      jfinal = (a.final.find(j)!=a.final.end());
      if (ifinal && jfinal) nerode[i][j] = 1;
      else if (ifinal||jfinal) nerode[i][j] = 0;
      else nerode[i][j] = -1;
    }
  }
  return equivalence(a,*(a.init.begin()),b,*(b.init.begin()));
}

int main() {
  int N,c,d,maxa,maxb;
  char C;
  automate a,b,amin,bmin;
  while (cin >> N) {
    maxa = 0;
    maxb = 0;
    for (int i=0; i<N; ++i) {
      cin >> c >> C >> d;
      maxa = max(c,max(d,maxa));
      --c;
      --d;
      a.delta.reserve(maxa);
      a.delta[c].push_back(trans(C,d));
    }
    cin >> N;
    for (int i=0; i<N; ++i) {
      cin >> c >> C >> d;
      maxb = max(c,max(d,maxb));
      --c;
      --d;
      b.delta.reserve(maxb);
      b.delta[c].push_back(trans(C,d));
    }
    //minimise(a,amin);
    //minimise(b,bmin);
    a.clear();
    b.clear();
  }
  return 0;
}
