#!/usr/bin/env python3

# Frobenius coin problem: given P = {pᵢ}, GCD(P) = 1,
# what is the greatest integer that cannot be written
# as ∑cᵢpᵢ for all cᵢ ≥ 0 integers?

# Lemma: For P = {pᵢ} positive integers, d = GCD(P), C = { ∑cᵢpᵢ, cᵢ ≥ 0},
# there exists N such that for all n ≥ N, all multiples of d are in C.
# (NB: - Clearly all elements of C are multiples of d.
#      - This basically says that the "positive cone" ultimately coincides
#        with the ideal of ℤ generated by P.)
# Proof: The general case is easily deduced from the d = 1 case (simply
#  factor by d). Then, using Bezout, there exists ∑aᵢpᵢ = 1.
#  Method 1: For p = min P, it is enough to prove that C contains an
#   interval of size p. Let us fix K > 0 and consider A = -K min aᵢ ≥ 0
#   and N = ∑Apᵢ. Then N+k = ∑Apᵢ + k∑aᵢpᵢ = ∑(A+kaᵢ)pᵢ is in C for
#   all 0 ≤ k ≤ K. Then choosing K = p-1 does the trick.
#  Method 2: Split ∑aᵢpᵢ = A - B where B gathers the negative aᵢ.
#   Consider the Euclidean division of some n by B,
#   n = qB + r = qB + r(A-B) = rA + (q-r)B with 0 ≤ r < B.
#   Then for all n ≥ N = B(B-1), q ≥ B-1 ≥ r, hence n is in C.

# Approach: Let p₀ = min P
#  Generate all ∑cᵢpᵢ combinations in increasing
#  order using a heap / priority queue.
#  Stop when p₀ consecutive values have been generated
#  (then using p₀ only, any higher value can be reached).

# This can deal with much larger inputs than the ones
# given here (e.g. runs in ~1s for N = 10⁴ and pᵢ ≤ 10⁶).

from heapq import *
from math import gcd

N = int(input())
P = [int(input()) for _ in range(N)]

g = 0
for p in P:
    g = gcd(p, g)
if g>1:
    print(-1)
else:
    Q = P.copy()
    heapify(Q)
    min_p = Q[0]
    Seen = set(Q)
    last_x = consec = 0
    while consec < min_p:
        x = heappop(Q)
        if x == last_x+1: consec += 1
        else:             consec  = 1
        last_x = x
        for p in P:
            y = x+p
            if y not in Seen:
                heappush(Q, y)
                Seen.add(y)
    print(last_x - min_p)
